#pragma once

#include "tools/sparse/definitions.h"

#include <string>
#include <vector>
#include <functional>

#include <rapidjson/document.h>

namespace snuffbox
{
  namespace sparse
  {
    /**
    * @brief The class that handles all parsing functionality from a .json
    *        generated by header-parser
    *
    * @author Daniel Konings
    */
    class JsonHeaderParser
    {

    public:

      /**
      * @brief Default constructor
      */
      JsonHeaderParser();

      /**
      * @brief Parse the contents of a .json and stores it as a C++ structure
      *
      * The parser automatically logs errors to std::cerr, so that they can be
      * viewed during compilation.
      *
      * @param[in] input The path to the .json from the current 
      *                  working directory
      *
      * @return Was the parsing a success?
      */
      bool Parse(const std::string& input);

      /**
      * @return Does the parser have a document ready?
      *
      * @remarks If the parser has any errors, this evaluates to false
      */
      bool HasDocument() const;

      /**
      * @return The parsed class definitions from the input header
      */
      const ScriptDefinitions& definitions() const;

    protected:

      /**
      * @brief Short-hand for values, as they are mostly const-qualified
      */
      using RapidValue = const rapidjson::Value&;

      /**
      * @brief Short-hand for rapidjson array values
      */
      using RapidArray = rapidjson::GenericArray<true, rapidjson::Value>;

      /**
      * @brief Short-hand for rapidjson object values
      */
      using RapidObject = rapidjson::GenericObject<true, rapidjson::Value>;

      /**
      * @brief Short-hand for rapidjson::SizeType
      */
      using RapidIdx = rapidjson::SizeType;

      /**
      * @brief A RapidArray ForEach delegate
      */
      using RapidForEach = bool(RapidValue, RapidIdx);

      /**
      * @brief Call a lambda expression for each of the rapidjson array's
      *        elements
      *
      * The lambda should return whether the ForEach loop should continue or
      * not. False means the execution should not break, true means that we're
      * done with execution.
      *
      * @param[in] arr The array to for-each through
      * @param[in] del The delegate/lambda function to call
      */
      void ForEach(
        const RapidArray& arr, 
        const std::function<RapidForEach>& del);

      /**
      * @brief Parses the .json document after it has been parsed by
      *        rapidjson
      *
      * @param[in] doc The rapidjson document to parse
      *
      * @return Was the parsing a success?
      */
      bool ParseDocument(const rapidjson::Document& doc);

      /**
      * @brief Parses an array of members either from the root node or in
      *        a namespace
      *
      * @param[in] arr The array to parse
      * @param[in] ns The current namespace
      *
      * @return Was the parsing a success?
      */
      bool ParseRoot(const RapidArray& arr, const std::string& ns = "");

      /**
      * @brief Retrieves the "type" field from a .json value as a string
      *
      * @param[in] v The value to retrieve the type from
      *
      * @return The type name, or nullptr if it doesn't exist
      */
      const char* GetType(RapidValue v);

      /**
      * @brief Checks if a .json value derives from a specified class
      *
      * There is no need to specify namespaces, as the function simply
      * checks whether the substring is contained in the name of the parents
      * of the checked class.
      *
      * @param[in] name The base class name
      * @param[in] v The value to check
      *
      * @return Is the class derived from the specified base?
      */
      bool DerivesFrom(const char* name, RapidValue v);

      /**
      * @brief Parses a .json class value from a given namespace
      *
      * @param[in] v The class value
      * @param[in] ns The current namespace
      *
      * @return Was the parsing a success?
      */
      bool ParseClass(RapidValue v, const std::string& ns);

      /**
      * @brief Parses a .json enum value from a given namespace, optionally
      *        nested in a class
      *
      * @param[in] v The enum value
      * @param[in] ns The current namespace
      * @param[in] cl The nested class, or nullptr if it's globally accessible
      *
      * @return Was the parsing a success?
      */
      bool ParseEnum(RapidValue v, const std::string& ns, ClassDefinition* cl);

      /**
      * @brief Parses a .json class value's members
      *
      * @param[out] d The class definition to modify
      * @param[in] v The class value
      *
      * @return Was the parsing a success?
      */
      bool ParseClassMembers(ClassDefinition* d, RapidValue v);

      /**
      * @brief Sets the script name of a class definition
      *
      * @param[out] d The class definition to modify
      * @param[in] v The class value
      *
      * @return Was the parsing a success?
      */
      bool SetScriptName(ClassDefinition* d, RapidValue v);

      /**
      * @brief Parses the functions of a .json class value
      *
      * @param[out] d The class definition to modify
      * @param[in] v The class value
      *
      * @return Was the parsing a success?
      */
      bool ParseFunction(ClassDefinition* d, RapidValue v);

      /**
      * @brief Parses a .json type definition into an actual type definition
      *
      * @param[in] v The .json value of the type to parse
      *
      * @return The parsed type definition
      */
      TypeDefinition ParseTypeValue(RapidValue v);

      /**
      * @brief Clears the current list of definitions
      */
      void Clear();

    private:

      ScriptDefinitions definitions_; //!< All contained definitions

      bool has_error_; //!< Are there any errors?
    };
  }
}