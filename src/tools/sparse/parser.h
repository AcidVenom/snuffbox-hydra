#pragma once

#include <string>
#include <vector>

#include <rapidjson/document.h>

namespace snuffbox
{
  namespace sparse
  {
    /**
    * @brief The class that handles all parsing functionality from a .json
    *        generated by header-parser
    *
    * @author Daniel Konings
    */
    class Parser
    {

    public:

      /**
      * @brief Default constructor
      */
      Parser();

      /**
      * @brief Parse the contents of a .json and output the parse result
      *        to a specific directory
      *
      * The parser automatically logs errors to std::cerr, so that they can be
      * viewed during compilation.
      *
      * @param[in] input The path to the .json from the current 
      *                  working directory
      * @param[in] output The path to the file to output in the binary directory
      *
      * @return Was the parsing a success?
      */
      bool Parse(const std::string& input, const std::string& output);

    protected:

      /**
      * @brief Used to store class information of the current class
      *        being parsed
      *
      * This struct is created every time the parser reaches a "ParseClass"
      * function call. The ClassDefinition will be stored in 
      * Parser::definitions_ for later use.
      *
      * @author Daniel Konings
      */
      struct ClassDefinition
      {
        /**
        * @brief Default constructor
        */
        ClassDefinition();

        const char* c_name; //!< The C++ class name
        const char* s_name; //!< The script name
      };

      /**
      * @brief Parses the .json document after it has been parsed by
      *        rapidjson
      *
      * @param[in] doc The rapidjson document to parse
      *
      * @return Was the parsing a success?
      */
      bool ParseDocument(const rapidjson::Document& doc);

      /**
      * @brief Parses a .json array and finds all respective members to parse
      *
      * @param[in] arr The array to parse
      *
      * @return Was the parsing a success?
      */
      bool ParseArray(
        const rapidjson::GenericArray<true, rapidjson::Value>& arr);

      /**
      * @brief Retrieves the "type" field from a .json value as a string
      *
      * @param[in] val The value to retrieve the type from
      *
      * @return The type name, or nullptr if it doesn't exist
      */
      const char* GetType(const rapidjson::Value& val);

      /**
      * @brief Enters a namespace and appends it to the current namespace
      *
      * The parsing is then progressed from the 'members' field of the namespace
      *
      * @param[in] ns The namespace value to enter
      *
      * @return Was the parsing a success?
      */
      bool EnterNamespaces(const rapidjson::Value& ns);

      /**
      * @brief Parses a class and all its members
      *
      * @param[in] cl The class value to enter
      *
      * @return Was the parsing a success?
      */
      bool ParseClass(const rapidjson::Value& cl);

      /**
      * @brief Checks if a class value is derived from a specified class
      *        name
      *
      * The name is check without namespaces, there is no need to specify them
      *
      * @param[in] name The name of the base class
      * @param[in] cl The class value
      *
      * @return Is the class derived from the specified base class?
      */
      bool DerivesFrom(const char* name, const rapidjson::Value& cl);

      /**
      * @brief Retrieves the script name from a class's SCRIPT_NAME value
      *
      * @param[in] m The macro value
      *
      * @return The script name, or nullptr if it doesn't exist
      */
      const char* GetScriptName(const rapidjson::Value& m);

    private:

      std::string current_namespace_; //!< The current namespace
      unsigned int num_namespaces_; //!< The number of namespaces entered

      ClassDefinition current_; //!< The current class definition being parsed
      bool in_class_; //!< Are we currently parsing a class?
      std::vector<ClassDefinition> definitions_; //!< All parsed definitions
    };
  }
}